# Implementação e Refatoração (Java Spring Boot)

## 1. Geração de Código: AlertService

Abaixo apresento uma implementação robusta utilizando Spring Boot. Para o cálculo do hash (fingerprint), utilizei `SHA-256`. Para o cache com expiração automática (desduplicação), a melhor prática "Sênior" é evitar reinventar a roda e utilizar uma biblioteca de cache de alta performance como o **Caffeine** (ou Redis em ambiente distribuído), mas aqui implementarei com Caffeine pela simplicidade e eficiência em memória local.

**Dependências necessárias (Maven):**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
```

**Implementação:**

```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeUnit;
import javax.xml.bind.DatatypeConverter; // Ou usar HexFormat no Java 17+

@RestController
@RequestMapping("/alerts")
public class AlertController {

    private final AlertService alertService;

    public AlertController(AlertService alertService) {
        this.alertService = alertService;
    }

    @PostMapping
    public String processAlert(@RequestBody AlertDTO alert) {
        boolean processed = alertService.processAlert(alert);
        return processed ? "Alert processed" : "Alert deduplicated (ignored)";
    }
}

@Service
public class AlertService {

    // Cache configurado para expirar entradas após 5 minutos
    private final Cache<String, Boolean> deduplicationCache;

    public AlertService() {
        this.deduplicationCache = Caffeine.newBuilder()
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .maximumSize(10_000) // Proteção contra OutOfMemory
                .build();
    }

    public boolean processAlert(AlertDTO alert) {
        String fingerprint = generateFingerprint(alert);

        // Se estiver no cache, é duplicado
        if (deduplicationCache.getIfPresent(fingerprint) != null) {
            return false; // Descartar
        }

        // Adiciona ao cache e processa
        deduplicationCache.put(fingerprint, true);
        
        // Lógica de processamento real aqui...
        System.out.println("Processing alert: " + alert.getAlertname());
        
        return true;
    }

    private String generateFingerprint(AlertDTO alert) {
        try {
            String rawData = alert.getAlertname() + "|" + alert.getInstance() + "|" + alert.getSeverity();
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(rawData.getBytes(StandardCharsets.UTF_8));
            // Conversão simples para Hex (Java 17 usaria HexFormat)
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Error calculating fingerprint", e);
        }
    }
}

// DTO Simples
class AlertDTO {
    private String alertname;
    private String instance;
    private String severity;
    
    // Getters e Setters...
    public String getAlertname() { return alertname; }
    public String getInstance() { return instance; }
    public String getSeverity() { return severity; }
}
```

---

## 2. Refatoração: Deduplicator Thread-Safe

O código original sofre de problemas de concorrência e gerenciamento de memória. Abaixo, a versão refatorada.

**Melhorias aplicadas:**
1.  **Thread-Safety:** Uso de `ConcurrentHashMap` (ou abstração de Cache) para garantir acesso seguro entre threads.
2.  **Gerenciamento de Memória:** Implementação de política de expiração e tamanho máximo para evitar que o mapa cresça indefinidamente (`OutOfMemoryError`).
3.  **Atomicidade:** Uso de operações atômicas (`putIfAbsent` ou métodos do Cache) para evitar condições de corrida.

A melhor abordagem moderna em Java é usar o **Caffeine** (como feito acima), mas para fins didáticos de refatoração da classe específica, mostrarei uma versão usando `ConcurrentHashMap` com limpeza manual (caso não se possa adicionar dependências externas) e a versão ideal com Caffeine.

**Versão Ideal (com Caffeine):**

```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import java.util.concurrent.TimeUnit;

public class Deduplicator {
    
    private final Cache<String, Long> cache;

    public Deduplicator() {
        this.cache = Caffeine.newBuilder()
            .expireAfterWrite(5, TimeUnit.MINUTES) // Resolve o requisito de tempo
            .maximumSize(50_000) // Resolve o crescimento indefinido
            .build();
    }

    public boolean isDuplicate(String fingerprint) {
        // Se retornar valor, já existe e é válido (dentro dos 5 min)
        if (cache.getIfPresent(fingerprint) != null) {
            return true;
        }
        
        cache.put(fingerprint, System.currentTimeMillis());
        return false;
    }
}
```

---

## 3. Detecção de Bugs

Análise do código original fornecido:

```java
public class Deduplicator {
    private static Map<String, Long> cache = new HashMap<>(); // BUG 1, BUG 2
    public boolean isDuplicate(String fingerprint) {
        if (cache.containsKey(fingerprint)) { // BUG 3
            return true;
        }
        cache.put(fingerprint, System.currentTimeMillis()); // BUG 3
        return false;
    }
}
```

**Identificação dos Problemas:**

1.  **Concorrência (Race Condition):** O uso de `HashMap` padrão não é *thread-safe*. Se múltiplas threads acessarem `isDuplicate` simultaneamente, o estado interno do mapa pode ser corrompido (ex: loop infinito interno durante rehash) ou lançar exceções.
2.  **Concorrência (Check-then-Act):** Mesmo que o mapa fosse thread-safe (ex: `Hashtable`), a lógica "verifica se existe" (`containsKey`) seguida de "insere" (`put`) não é atômica. Duas threads podem verificar simultaneamente, ambas receberem `false`, e ambas inserirem, falhando na desduplicação.
3.  **Vazamento de Memória (Memory Leak):** O campo `cache` é `static` e nunca remove itens. Ele crescerá indefinidamente até consumir toda a memória da JVM (`java.lang.OutOfMemoryError: Java heap space`), pois não há política de despejo (eviction) ou limpeza de chaves antigas.
4.  **Lógica Incompleta:** O código armazena o `System.currentTimeMillis()`, mas nunca verifica esse valor. Uma vez que um fingerprint entra no cache, ele retorna `true` para sempre. O requisito de "menos de 5 minutos" não é atendido; a implementação atual faz uma desduplicação eterna.
