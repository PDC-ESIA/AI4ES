# Refatoração: Módulo de Notificações com Strategy Pattern

Este documento apresenta a refatoração do módulo de notificações do `AlertService` para aderir aos princípios SOLID, especificamente o Open/Closed Principle (OCP), eliminando condicionais rígidas (`if/else`) e facilitando a extensão para novos canais.

## 1. Sugestão de Padrão de Projeto: Strategy

Para resolver o problema de acoplamento e violação do OCP causado pelos múltiplos `if/else` para verificar o tipo de canal, o padrão de projeto **Strategy** é a escolha ideal.

**Conceito:**
O padrão Strategy define uma família de algoritmos (neste caso, métodos de envio de notificação), encapsula cada um deles em uma classe separada e os torna intercambiáveis. Isso permite que o algoritmo varie independentemente dos clientes que o utilizam.

**Aplicação no AlertService:**
Em vez de o `NotificationService` saber *como* enviar para cada canal, ele delegará essa responsabilidade para implementações concretas de uma interface comum (`NotificationChannelStrategy`). O serviço apenas identificará qual estratégia usar baseada no tipo de notificação configurada.

---

## 2. Implementação em Java (Spring Boot)

Abaixo está a implementação demonstrando como utilizar o recurso de injeção de dependência do Spring para registrar e selecionar as estratégias automaticamente.

### 2.1. A Interface (Strategy)

Definimos um contrato comum para todos os canais de notificação.

```java
package com.criticalevent.alertservice.notification.strategy;

import com.criticalevent.alertservice.model.Alert;

public interface NotificationChannelStrategy {
    /**
     * Envia o alerta para o canal específico.
     */
    void send(Alert alert);

    /**
     * Identifica qual tipo de canal esta estratégia suporta.
     * Ex: "SLACK", "EMAIL", "PAGERDUTY".
     */
    boolean supports(String channelType);
}
```

### 2.2. Implementações Concretas

Cada canal é uma classe separada, facilitando a manutenção e testes isolados.

```java
package com.criticalevent.alertservice.notification.strategy.impl;

import com.criticalevent.alertservice.notification.strategy.NotificationChannelStrategy;
import com.criticalevent.alertservice.model.Alert;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class SlackChannelStrategy implements NotificationChannelStrategy {

    @Override
    public void send(Alert alert) {
        // Lógica específica do Slack (ex: WebClient call)
        log.info("Enviando alerta [{}] para o SLACK...", alert.getId());
    }

    @Override
    public boolean supports(String channelType) {
        return "SLACK".equalsIgnoreCase(channelType);
    }
}
```

```java
package com.criticalevent.alertservice.notification.strategy.impl;

import com.criticalevent.alertservice.notification.strategy.NotificationChannelStrategy;
import com.criticalevent.alertservice.model.Alert;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class EmailChannelStrategy implements NotificationChannelStrategy {

    @Override
    public void send(Alert alert) {
        // Lógica específica de Email (ex: JavaMailSender)
        log.info("Enviando alerta [{}] via EMAIL...", alert.getId());
    }

    @Override
    public boolean supports(String channelType) {
        return "EMAIL".equalsIgnoreCase(channelType);
    }
}
```

### 2.3. O Contexto (Service)

O `NotificationService` recebe todas as estratégias disponíveis via injeção de dependência do Spring. Ele não precisa ser alterado quando um novo canal é adicionado.

```java
package com.criticalevent.alertservice.service;

import com.criticalevent.alertservice.model.Alert;
import com.criticalevent.alertservice.notification.strategy.NotificationChannelStrategy;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class NotificationService {

    private final List<NotificationChannelStrategy> strategies;

    // O Spring injeta automaticamente todas as classes que implementam a interface
    public NotificationService(List<NotificationChannelStrategy> strategies) {
        this.strategies = strategies;
    }

    public void notify(Alert alert, String channelType) {
        NotificationChannelStrategy strategy = strategies.stream()
            .filter(s -> s.supports(channelType))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Canal de notificação não suportado: " + channelType));

        strategy.send(alert);
    }
}
```

---

## 3. Justificativa

A escolha do padrão **Strategy** combinada com a injeção de dependência do Spring oferece os seguintes benefícios para este problema específico:

1.  **Adesão ao Open/Closed Principle (OCP):**
    *   O código está **aberto para extensão**: Para adicionar um novo canal (ex: Microsoft Teams), basta criar uma nova classe `TeamsChannelStrategy` anotada com `@Component`.
    *   O código está **fechado para modificação**: A classe `NotificationService` **não precisa ser tocada** para suportar o novo canal. O Spring descobre a nova estratégia automaticamente e a injeta na lista.

2.  **Eliminação de Condicionais Complexas:**
    *   A lógica de `if (type == "SLACK") ... else if (type == "EMAIL")` desaparece, delegando a decisão para o método `supports()` ou para um mapa de estratégias. Isso reduz a complexidade ciclomática do método principal.

3.  **Facilidade de Testes Unitários:**
    *   Cada estratégia (`SlackChannelStrategy`, `EmailChannelStrategy`) pode ser testada isoladamente sem dependências dos outros canais.
    *   O `NotificationService` pode ser testado facilmente mockando a lista de estratégias, garantindo que ele chama o método `send()` da estratégia correta.

4.  **Desacoplamento:**
    *   O serviço de notificação não conhece os detalhes de implementação de cada canal (ex: bibliotecas de terceiros, configurações de API), dependendo apenas da abstração `NotificationChannelStrategy`.
