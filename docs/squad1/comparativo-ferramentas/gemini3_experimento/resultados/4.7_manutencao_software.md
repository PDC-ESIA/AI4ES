# 4.7. Manutenção de Software

## 1. Análise de Código (Bug de Concorrência)

O código original falha em ambientes multithread devido a uma condição de corrida clássica do tipo **"Check-then-Act"** (Verificar-depois-Agir).

*   **O Problema:** As operações `containsKey` (verificação) e `put` (inserção) não são atômicas em conjunto.
*   **Cenário de Falha:**
    1.  A **Thread A** verifica `cache.containsKey(fingerprint)` e recebe `false`.
    2.  A **Thread A** é interrompida (ou entra no `sleep`).
    3.  A **Thread B** verifica a mesma `fingerprint`. Como a Thread A ainda não executou o `put`, a Thread B também recebe `false`.
    4.  Ambas as threads executam o `put` e retornam `false`, permitindo que alertas duplicados sejam processados.

## 2. Correção Automatizada

Para corrigir o problema mantendo alta performance (evitando blocos `synchronized` pesados em todo o método), a melhor abordagem é utilizar `ConcurrentHashMap` e seu método atômico `putIfAbsent`.

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class DeduplicationService {

    // Substituição por ConcurrentHashMap para suporte a concorrência
    private final Map<String, Long> cache = new ConcurrentHashMap<>();

    public boolean isDuplicate(String fingerprint) {
        // putIfAbsent é uma operação atômica.
        // Retorna null se a chave não existia (e insere o valor).
        // Retorna o valor existente se a chave já estava lá.
        Long previousValue = cache.putIfAbsent(fingerprint, System.currentTimeMillis());
        
        // Se retornou algo diferente de null, já existia -> é duplicado.
        return previousValue != null;
    }
}
```

## 3. Refatoração Preventiva (Memory Leak)

O uso de um `Map` simples (seja `HashMap` ou `ConcurrentHashMap`) sem uma estratégia de remoção causará um vazamento de memória (*Memory Leak*), pois o mapa crescerá indefinidamente conforme novos alertas chegam.

**Sugestão:** Utilizar uma estrutura de Cache com política de expiração (TTL - Time To Live) ou tamanho máximo.

**Implementação Recomendada (usando biblioteca Caffeine ou Guava):**

```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import java.util.concurrent.TimeUnit;

public class DeduplicationService {

    // Configura expiração automática após 1 hora e limite máximo de entradas
    private final Cache<String, Long> cache = Caffeine.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .maximumSize(100_000)
            .build();

    public boolean isDuplicate(String fingerprint) {
        // Verifica se existe de forma thread-safe
        if (cache.getIfPresent(fingerprint) != null) {
            return true;
        }
        
        // Insere no cache
        cache.put(fingerprint, System.currentTimeMillis());
        return false;
    }
}
```
