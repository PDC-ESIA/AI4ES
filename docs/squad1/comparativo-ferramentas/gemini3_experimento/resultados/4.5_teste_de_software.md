# 4.5 Teste de Software

## Prompt
> Atue como um Engenheiro de QA (Quality Assurance) especialista em testes automatizados em Java.
> Com base no código do `AlertService` gerado anteriormente (Spring Boot), realize as seguintes tarefas:
> 1. **Geração de testes (unit., integração, aceitação):** Crie uma classe de teste usando **JUnit 5** e **Mockito**. Cubra os seguintes cenários:
>    * Alerta novo deve ser processado (retornar 200 OK).
>    * Alerta duplicado (mesmo fingerprint dentro da janela de tempo) deve ser ignorado (retornar 200 OK ou 202 Accepted, mas não processar).
>    * Payload inválido (campos obrigatórios faltando) deve retornar 400 Bad Request.
> 2. **Execução de testes automatizados:** (Pergunta teórica) Como eu poderia integrar esses testes em um pipeline de CI/CD para rodar automaticamente a cada commit? Forneça o comando Maven/Gradle para executar apenas estes testes.

---

## Resposta

Como Engenheiro de QA, analisei o código do `AlertService` e do `AlertController`. Para cobrir os cenários solicitados que envolvem códigos de status HTTP (200, 400), a estratégia mais eficaz é utilizar um teste de integração de fatia (**Slice Test**) focado na camada Web, utilizando `@WebMvcTest`. Isso nos permite testar o comportamento do endpoint HTTP enquanto simulamos (mockamos) a lógica de negócio do serviço.

### 1. Geração de Testes (JUnit 5 + Mockito)

Para que o cenário de "Payload inválido" (400 Bad Request) funcione corretamente, é pré-requisito que o DTO utilize anotações do **Bean Validation** (como `@NotNull`, `@NotBlank`) e que o Controller utilize a anotação `@Valid`.

Abaixo está a implementação da classe de teste `AlertControllerTest`.

```java
package com.example.monitoring.controller;

import com.example.monitoring.dto.AlertDTO;
import com.example.monitoring.service.AlertService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(AlertController.class)
class AlertControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private AlertService alertService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("Cenário 1: Alerta novo deve ser processado (200 OK)")
    void shouldProcessNewAlert() throws Exception {
        // Arrange
        AlertDTO alert = new AlertDTO("HighCPU", "server-01", "critical");
        
        // Mockando o serviço para retornar true (processado)
        when(alertService.processAlert(any(AlertDTO.class))).thenReturn(true);

        // Act & Assert
        mockMvc.perform(post("/alerts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(alert)))
                .andExpect(status().isOk())
                .andExpect(content().string("Alert processed"));

        // Verifica se o serviço foi chamado exatamente uma vez
        verify(alertService, times(1)).processAlert(any(AlertDTO.class));
    }

    @Test
    @DisplayName("Cenário 2: Alerta duplicado deve ser ignorado (200 OK)")
    void shouldIgnoreDuplicateAlert() throws Exception {
        // Arrange
        AlertDTO alert = new AlertDTO("HighCPU", "server-01", "critical");
        
        // Mockando o serviço para retornar false (duplicado/ignorado)
        when(alertService.processAlert(any(AlertDTO.class))).thenReturn(false);

        // Act & Assert
        mockMvc.perform(post("/alerts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(alert)))
                .andExpect(status().isOk()) // O requisito pede 200 ou 202. O código atual retorna 200.
                .andExpect(content().string("Alert deduplicated (ignored)"));

        // Verifica se o serviço foi chamado (pois a lógica de check está no serviço)
        verify(alertService, times(1)).processAlert(any(AlertDTO.class));
    }

    @Test
    @DisplayName("Cenário 3: Payload inválido deve retornar 400 Bad Request")
    void shouldReturn400ForInvalidPayload() throws Exception {
        // Arrange
        // Criando um DTO inválido (ex: alertname nulo)
        AlertDTO invalidAlert = new AlertDTO(null, "", "critical");

        // Act & Assert
        mockMvc.perform(post("/alerts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(invalidAlert)))
                .andExpect(status().isBadRequest()); // Espera HTTP 400
        
        // Garante que o serviço de negócio NUNCA foi acionado para dados inválidos
        verify(alertService, never()).processAlert(any());
    }
}
```

### 2. Execução de Testes Automatizados (CI/CD)

#### Integração em Pipeline
Para integrar esses testes em um pipeline de CI/CD (Continuous Integration / Continuous Delivery), como GitHub Actions, GitLab CI ou Jenkins, o processo deve ser configurado para bloquear a integração de código caso algum teste falhe.

O fluxo típico seria:
1.  **Checkout:** O pipeline baixa o código fonte do commit recente.
2.  **Setup Environment:** Configura o JDK (Java Development Kit) adequado.
3.  **Build & Test:** Executa o comando de build que inclui a fase de testes. Se o comando retornar um código de saída diferente de 0 (erro), o pipeline falha e notifica a equipe.

#### Comandos de Execução

Para rodar **apenas** a classe de teste criada (`AlertControllerTest`), utilize os comandos abaixo dependendo do seu gerenciador de dependências:

**Maven:**
```bash
mvn -Dtest=AlertControllerTest test
```

**Gradle:**
```bash
./gradlew test --tests "com.example.monitoring.controller.AlertControllerTest"
```
